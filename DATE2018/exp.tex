\section{EXPERIMENTAL SETTING, RESULTS AND DISCUSSION}
\label{sec:exp}
\subsection{Experimental Setting}
The proposed framework for aging tolerance is implemented in C++ and the SAT-based formulation is solved by MiniSat on a 2.83GHz Intel Quad-Core CPU workstation running Linux. The benchmark circuits are chosen from the IWLS'05 and ISCAS'89 suites. The technology used is TSMC 45nm GP standard cell series.

Under 10-year BTI, the aging rates of clock buffers were obtained from HSPICE. The aging rates of clock buffers with duty cycles of 20\%, 40\%, 50\%, and 80\% are 8.51\%, 12.08\%, 13.51\%, and 16.41\% respectively and the aging rate of logic is obtained by using the predictive model presented in~\cite{wang2010impact, wang2007efficient, gomez2016early} (detailed in Section~\ref{subsec:apm}).


\begin{table*}
\centering
\caption{Benchmark information}
	%\begin{tabular}{l}
	%\includegraphics[width=2.03\columnwidth]{Experimental_result_DCC_TVA.png} %IEEE
	\includegraphics[width=0.47\columnwidth]{benchmark.png} %ACM
	%\end{tabular}
\label{table:exp1}
\end{table*}
\begin{table*}
\centering
\caption{Results of aging tolerance}
	%\begin{tabular}{l}
	%\includegraphics[width=2.03\columnwidth]{Experimental_result_DCC_TVA.png} %IEEE
	\includegraphics[width=1\columnwidth]{Experimental_result_DCC_TVA.png} %ACM
	%\end{tabular}
\label{table:exp2}
\end{table*}
\subsection{Experimental Results}
Table~\ref{table:exp1} and Table~\ref{table:exp2} reports the information of each benchmark and the experimental results. In Table~\ref{table:exp1}, Columns 2 to 5 show the total count of gates, total count of flip-flops, total count of clock buffers, and maximum level of the clock tree in each benchmark respectively. In Table~\ref{table:exp2}, Column 4 to 7 show the results when DCC deployment is considered in the framework. Column 8 to 12 show the results when high-$V_{th}$ assignment for clock buffers is applied on top of DCC deployment.

In Table~\ref{table:exp2}, Column 2  demonstrates the fresh clock period that is the circuit delay without aging, denoted by $T_{c\_fresh}$. Column 3 demonstrates the clock period of the circuit under 10-year aging, denoted by $T_{c\_aged}$. Column 4 and 8 demonstrate the optimum clock period of the circuit under 10-year aging after applying our framework, denoted by $T_{c\_aged\_opt}$. A shorter clock period under aging implies better circuit performance and higher level of aging tolerance. Column 5 and 9 demonstrate the used DCC count. Column 6 and 11 demonstrate the runtime and the Column 7 and 12 demonstrate the improvement, i.e., the level of aging tolerance which is calculated as:
\begin{gather*}
1 - (T_{c\_aged\_opt} - T_{c\_fresh}) / (T_{c\_aged} - T_{c\_fresh})
\end{gather*}

For benchmark \textit{des\_perf}, $T_{c\_fresh}$ is 773.9ps and $T_{c\_aged}$ is 897.8ps, which means after 10-year aging the clock period of circuit will increase by 123.9ps. With DCC insertion using the proposed framework, the clock period achieved is 849.9ps, an increment of 76ps against $T_{c\_fresh}$ (38.66\% improvement). With high-$V_{th}$ assignment applied on top of DCC insertion, the clock period drops to 816.8ps, a smaller increment of 42.9ps against $T_{c\_fresh}$ (65.38\% improvement), implying better aging tolerance. As shown in Table~\ref{table:exp2}, with DCC deployment, the improvement ranges from 7.38\% to 49.77\% and is 24.95\% on average; with high-$V_{th}$ assignment applied on top of DCC deployment, we can achieve better improvement, ranging from 13.97\% to 65.97\% and being 37.61\% on average. The count of inserted DCCs is between 1 (for benchmark \textit{s13207} and \textit{netcard}) to 35 (for benchmark \textit{des\_perf}). The inserted DCC count only has the small proportion of the total buffer count (e.g., at most 3.4\%($= 13/376$) for \textit{s38417}), implying very limited degree of circuit modification and insignificant design overhead. %Moreover, as it can be seen in Column 8 to 12, when high-$V_{th}$ assignment for clock buffers is incorporated in the proposed framework, the resulting framework can give rise to lower clock periods (Column 8), implying better improvement in aging tolerance. 

\subsection{Discussion: DCC Redeployment due to High-$V_{th}$ Assignment for Clock Buffers}
As we can see, the DCC counts in Column 9 are different from those in Column 5, implying that DCCs are redeployed in the clock tree while high-$V_{th}$ assignment is incorporated in the framework. More specifically, when high-$V_{th}$ assignment is considered, some clock buffers become candidate buffers to be inserted DCCs at their inputs, because timing constraints (i.e., setup-time and hold-time) are met based on the inequality Equation~(\ref{eq:tsu}) and (\ref{eq:th}). In this way, DCCs can be redeployed to obtain lower clock periods, exploring better improvement in aging tolerance.


%Compare the DCC counts in Column 9 with those in Column 13, we can find that, while $V_{th}^h$ assignment is involved in the framework, it may redeploy the DCCs in the clock tree and thus results in different DCC count. Specifically speaking, when $V_{th}^h$ assignment is considered, some clock buffers become candidate buffers to be inserted DCCs at their inputs, because timing constraints (i.e., setup-time and hold-time) are met based on the inequality Equation (1) and (2). In this way, DCCs can be redeployed to obtain lower clock periods.

%Take \textit{des\_perf} for example, DCC count is 7; however, the DCC count increases to 33 after $V_{th}^h$ assignment is involved. The DCC counts of the same design differ because the DCC deployments are not identical anymore. Specifically speaking, when V\textsubscript{th} assignment is considered, some clock buffers become candidate buffers to be inserted DCC at their inputs, because timing constraints (i.e., setup-time and hold-time) are met based on the inequality Equation (1) and (2), such that DCC can be redeployed to obtain lower Tc. Thus, even thought the two frameworks target the identical benchmark, the DCC deployments/counts may differ. 

\subsection{Discussion: Increase in Runtime}
In addition, the run time of the framework, incorporating high-$V_{th}$ assignment, increases due to the possibility explosion of DCC deployment and leader selection. To be specific, given a pair of flip-flops and associated clock paths, we need to consider the various possibilities of leader selections, for each DCC deployment. Therefore, the total  count of DCC deployment and leader selection is equal to the combination of DCC deployment plus leader selection, i.e., DCC possibilities multiplied by the leader counterparts, accounting for the increase of run time. 

Even though the runtime increases while high-$V_{th}$ assignment is incorporated, the resulting framework is still practical for aging tolerance because it at most takes 1370 seconds for a comparative design (e.g., \textit{netcard}).
\subsection{Discussion: Aging Impact on DCC}
\begin{figure}
    \centering
    %\includegraphics[width=0.9\columnwidth]{Aging_impacted_on_DCC.png} %IEEE
     \includegraphics[width=0.6\columnwidth]{Aging_impacted_on_DCC.png} %ACM
    \caption{Aging impact on 20\%/80\% DCC under BTI}
    \label{fig:exp4}
\end{figure}

Figure~\ref{fig:exp4} shows the change in the duty cycle of a 20\%/80\% DCC over 10-year aging. The y axis on the left represents the duty cycle of a 20\% DCC, and the one on the right represents the duty cycle of an 80\% DCC. As it can be seen, the growth in both cases are marginal: $20\% \to 21.07\%$ for a 20\% DCC and $80\% \to 81.35\%$ for an 80\% DCC, which in turn should not affect the benefit of our proposed framework significantly.


\subsection{Discussion: Depth Boundary for DCC Deployment}
\begin{figure}
    \centering
    %\includegraphics[width=0.9\columnwidth]{Boundary_level_vs_improvement.png} %IEEE
    \includegraphics[width=0.6\columnwidth]{Boundary_level_vs_improvement.png} %ACM
    \caption{Improvement/Cost versus clock tree level considered}
    \label{fig:boundary}
\end{figure}

As mentioned in Section~\ref{sec:framework}, inserting DCCs deep in the clock tree is less effective. For benchmark \textit{des\_perf}, we considered the deployment of DCCs at the upper half of the clock tree (i.e., level 1 to 5) and achieved 38.66\% improvement in terms of aging tolerance. As demonstrated in Figure~\ref{fig:boundary}, if we expand the boundary of DCC deployment from level 1 in the clock tree to level 10 progressively, we can gain a considerable improvement from level 1 to 6; however, from 7 to 10, the improvement become stagnant, but more DCCs are required.